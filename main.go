package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"sort"
	"strings"
	"text/template"
	"time"

	"github.com/compose-spec/compose-go/cli"
	"github.com/compose-spec/compose-go/types"
)

// A systemd service
type Service struct {
	Name              string
	BindsTo           []string
	Wants             []string
	After             []string
	Before            []string
	RequiresMountsFor []string
	Requires          []string

	Restart      string
	RestartOn    string
	ExecStartPre []string
	ExecStart    string
	ExecStop     string
	ExecStopPost string
	PIDFile      string
	Type         string
	NotifyAccess string

	ContainerEnvironments map[string]string
	ContainerVolumes      []string
	ContainerImage        string
	ContainerCommand      string
}

func NewPodService(project *types.Project) Service {
	var services = ServiceNames(project)
	var ports = ServicePorts(project)
	sortedServices := containerServiceNames(project.Name, services)
	sort.Strings(sortedServices)
	return Service{
		Name:   podServiceName(project.Name),
		Wants:  sortedServices,
		Before: sortedServices,

		Restart: "on-failure",
		ExecStartPre: []string{
			"/bin/rm -f %t/%N.pid %t/%N.pod-id",
			fmt.Sprintf("/usr/bin/podman pod create --infra-conmon-pidfile %%t/%%N.pid --pod-id-file %%t/%%N.pod-id --name %%N -p %s --replace", strings.Join(ports, " -p ")),
		},
		ExecStart:    "/usr/bin/podman pod start --pod-id-file %t/%N.pod-id",
		ExecStop:     "/usr/bin/podman pod stop --ignore --pod-id-file %t/%N.pod-id -t 10",
		ExecStopPost: "/usr/bin/podman pod rm --ignore -f --pod-id-file %t/%N.pod-id",
		PIDFile:      "%t/%N.pid",
		Type:         "forking",
	}
}

func podServiceName(project string) string {
	return fmt.Sprintf("%s-pod.service", project)
}
func containerServiceName(project, service string) string {
	return fmt.Sprintf("%s-%s.service", project, service)
}

func containerServiceNames(project string, services []string) []string {
	res := make([]string, len(services))
	for i, s := range services {
		res[i] = fmt.Sprintf("%s-%s.service", project, s)
	}
	return res
}

func NewContainerService(project string, service *types.ServiceConfig) Service {
	var dependencies = DependencyNames(service)
	return Service{
		Name:              containerServiceName(project, service.Name),
		Wants:             containerServiceNames(project, dependencies),
		RequiresMountsFor: []string{"%t/containers"},
		BindsTo:           []string{podServiceName(project)},
		After:             append([]string{podServiceName(project)}, containerServiceNames(project, dependencies)...),

		Restart:      service.Restart,
		ExecStartPre: []string{"/bin/rm -f %t/%n.ctr-id"},
		ExecStart:    fmt.Sprintf("/usr/bin/podman container run --cidfile=%%t/%%n.ctr-id --cgroups=no-conmon --rm --pod-id-file %%t/%s-pod.pod-id --sdnotify=conmon -d --replace --name=%%N", project),
		ExecStop:     "/usr/bin/podman stop --ignore --cidfile=%t/%n.ctr-id",
		ExecStopPost: "/usr/bin/podman rm -f --ignore --cidfile=%t/%n.ctr-id",
		Type:         "notify",
		NotifyAccess: "all",

		ContainerEnvironments: ServiceEnvVariables(service),
		ContainerVolumes:      ServiceVolumes(service),
		ContainerImage:        service.Image,
		ContainerCommand:      strings.Join(service.Command, " "),
	}
}

func ServiceNames(project *types.Project) []string {
	res := make([]string, len(project.Services))
	for i, s := range project.Services {
		res[i] = s.Name
	}
	return res
}
func DependencyNames(service *types.ServiceConfig) []string {
	res := make([]string, len(service.DependsOn))
	i := 0
	for k, _ := range service.DependsOn {
		res[i] = k
		i++
	}
	return res
}
func ServicePorts(project *types.Project) []string {
	res := make([]string, 0)
	for _, s := range project.Services {
		for _, p := range s.Ports {
			ip := p.HostIP
			if ip == "" {
				ip = "0.0.0.0"
			}
			res = append(res, fmt.Sprintf("%s:%s:%d", ip, p.Published, p.Target))
		}
	}
	return res
}
func ServiceEnvVariables(service *types.ServiceConfig) map[string]string {
	res := make(map[string]string, len(service.Environment))
	for k, v := range service.Environment {
		if v == nil {
			res[k] = ""
		} else {
			res[k] = *v
		}
	}
	return res
}

func ServiceVolumes(service *types.ServiceConfig) []string {
	res := make([]string, len(service.Volumes))
	for i, v := range service.Volumes {
		if v.ReadOnly {
			res[i] = fmt.Sprintf("%s:%s:ro", v.Source, v.Target)
		} else {
			res[i] = fmt.Sprintf("%s:%s", v.Source, v.Target)
		}
	}
	return res
}

const systemd_unit = `
# {{.Service.Name}}
# autogenerated by compose-systemd
# {{.Datetime.Format "Mon Jan 02 15:04:05 MST 2006"}}

[Unit]
Description=Podman {{.Service.Name}}
Documentation=man:podman-generate-systemd(1)
Wants=network-online.target
After=network-online.target
RequiresMountsFor={{ range .Service.RequiresMountsFor}}{{.}} {{- end}}
{{- if .Service.Wants }}
Wants={{ range .Service.Wants}}{{.}} {{end}}
{{- end -}}
{{- if .Service.Before }}
Before={{ range .Service.Before}}{{.}} {{end}}
{{- end -}}
{{- if .Service.BindsTo }}
BindsTo={{ range .Service.BindsTo}}{{.}} {{end}}
{{- end -}}
{{- if .Service.After }}
After={{ range .Service.After}}{{.}} {{end}}
{{- end}}

[Service]
Environment=PODMAN_SYSTEMD_UNIT=%n
{{- if .Service.ContainerEnvironments }}
	{{- range $k, $v := .Service.ContainerEnvironments }}
Environment={{ $k }}={{ $v }}
	{{- end }}
{{- end }}
{{- if .Service.Restart }}
Restart={{.Service.Restart}}
{{- end }}
TimeoutStopSec=70
{{- range .Service.ExecStartPre }}
ExecStartPre={{.}}
{{- end }}
ExecStart={{.Service.ExecStart}} {{- range $k, $v := .Service.ContainerEnvironments }} -e {{ $k }}{{ end }} {{- range $k, $v := .Service.ContainerVolumes }} -v {{ $v }}{{ end }} {{.Service.ContainerImage}} {{.Service.ContainerCommand}}
ExecStop={{.Service.ExecStop}}
ExecStopPost={{.Service.ExecStopPost}}
{{- if .Service.PIDFile }}
PIDFile={{.Service.PIDFile}}
{{- end }}
Type={{.Service.Type}}
{{- if .Service.NotifyAccess }}
NotifyAccess={{.Service.NotifyAccess}}
{{- end }}

[Install]
WantedBy=multi-user.target default.target
`

var unitTemplate = template.Must(template.New("systemd").Parse(systemd_unit))

func generateUnit(s Service) string {
	sb := &strings.Builder{}
	err := unitTemplate.Execute(sb, struct {
		Datetime time.Time
		Service  Service
	}{
		Datetime: time.Now(),
		Service:  s,
	})
	if err != nil {
		log.Fatal(err)
	}
	return sb.String()
}

func main() {
	opts, err := cli.NewProjectOptions(nil, cli.WithDefaultConfigPath)
	if err != nil {
		log.Fatal(err)
	}
	project, err := cli.ProjectFromOptions(opts)
	if err != nil {
		log.Fatal(err)
	}

	systemdServices := make(map[string]Service, len(project.Services)+1)
	systemdServices[podServiceName(project.Name)] = NewPodService(project)
	for _, s := range project.Services {
		systemdServices[containerServiceName(project.Name, s.Name)] = NewContainerService(project.Name, &s)
	}

	for n, u := range systemdServices {
		ioutil.WriteFile(n, []byte(generateUnit(u)), 0644)
	}
}
